% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LocASN.R
\name{LocASN}
\alias{LocASN}
\title{Single-cell RNA sequencing normalization using a local average technique}
\usage{
LocASN(
  countmatrix,
  conditions = NULL,
  filter = FALSE,
  gene_num_gezero = 3,
  cell_num_gezero = 10,
  numGeneforEst = 2000,
  divideforFast = TRUE,
  numDivide = NULL,
  bw.method = "SJ"
)
}
\arguments{
\item{countmatrix}{Input. Unnormalized count matrix (genes by cells).}

\item{conditions}{Input (Optional). Indicate which cells are sampled from the same conditions.
The default value, NULL, denotes all the cells are sampled from the same condition.}

\item{filter}{Input (Optional). A logic value to indicate if need data filtering. If TRUE, please see
the details of gene_num_gezero and cell_num_gezero for input. The default value is FALSE.}

\item{gene_num_gezero}{Input (Optional). A threshold (interger) to determine the inclusion of a gene.
The gene included needs to be expressed in at least \emph{gene_num_gezero} cells.
The default value is 3.}

\item{cell_num_gezero}{Input (Optional). A threshold (interger) to determine the inclusion of a cell.
The cell included needs to contain at least \emph{cell_num_gezero} expressed genes.
The default value is 10.}

\item{numGeneforEst}{Input (Optional). Use top \emph{numGeneforEst} (integer) genes according to 
the proportions of gene counts > 0 in cells to estimate the scaling factors, 
for speeding up computation.}

\item{divideforFast}{Input (Optional). A logic value to indicate if speeding up computation
by randomly dividing cells in each condition into \emph{numDivide} smaller groups.
Please input an integer in \emph{numDivide} below if \emph{divideforFast} = TRUE.
The default value is TRUE.}

\item{numDivide}{Input (Optional). An integer is required if \emph{divideforFast} = TRUE.
The cells in each condition will be randomly divided by \emph{numDivide} small groups.
The default \emph{numDivide} = NULL will automatically use the maximum of 1 and the smallest integer 
that is not less than the number of cells in each condition divided by 3K, 
that means no division for conditions with less than 3K cells.}

\item{bw.method}{Input (Optional). A method to estimate the bandwidths in Kernel weighting. 
The default method uses "SJ" (SJ bandwidth, Sheather and Jones, 1991). 
Otherwise, uses "RoT" (rule-of-thumb, Silverman, 1986).}
}
\value{
\item{NormalizedData}{Matrix (genes by cells). Data matrix after normalization.}

\item{scalingFactor}{Vector. Cell-specific scaling factors.}

\item{delete_genes}{Vector. Indeice of the genes deleted.}

\item{delete_cells}{Vector. Indeice of the cells deleted.}
}
\description{
A function of normalizing single cell RNA-seq gene expression.
}
\examples{
set.seed(12345)
G <- 2000; n <- 600 # G: number of genes, n: number of cells
NB_cell <- function(j) rnbinom(G, size = 0.1, mu = rgamma(G, shape = 2, rate = 2))
countsimdata <- sapply(1:n, NB_cell)
colnames(countsimdata) <- paste("c", 1:n, sep = "_")
rownames(countsimdata) <- paste("g", 1:G, sep = "_")
Result <- LocASN(countmatrix = as(countsimdata,"sparseMatrix"))
Result$NormalizedData[1:10,1:10]; Result$scalingFactor[1:10]

#conditions <- c(rep(1,n/2), rep(2,n/2))
#Result2 <- LocASN(countmatrix = countsimdata, conditions = conditions)
#Result2$NormalizedData[1:10,1:10]; Result2$scalingFactor[1:10]
}
